package xjsnark.zkrollup1;

/*Generated by MPS */

import backend.structure.CircuitGenerator;
import backend.config.Config;
import backend.eval.SampleRun;
import java.math.BigInteger;
import backend.auxTypes.UnsignedInteger;
import util.Util;
import backend.auxTypes.Bit;
import backend.auxTypes.ConditionalScopeTracker;
import backend.eval.CircuitEvaluator;

public class Merkle8MB extends CircuitGenerator {



  public static void main(String[] args) {
    // This is the java main method. Its purpose is to make the Progam runnable in the environment 
    // This method can be left empty, or used to set Configuration params (see examples) 
    Config.writeCircuits = true;
    Config.outputFilesPath = "D:/downloads";
    new Merkle8MB();
  }

  public Merkle8MB() {
    super("Merkle8MB");
    __generateCircuit();
    this.__evaluateSampleRun(new SampleRun("Sample_Run18", true) {
      public void pre() {
        // verify merkle tree 输入 
        // check the equality between root and merkle_root 
        // input tx root === computed tx root 

        // generate merkle tree input 
        root.mapValue(new BigInteger("18"), CircuitGenerator.__getActiveCircuitGenerator().__getCircuitEvaluator());
        for (int i = 0; i < 18; i++) {
          path[i].mapValue(new BigInteger("1"), CircuitGenerator.__getActiveCircuitGenerator().__getCircuitEvaluator());
        }

        // ECDSA输入 

      }
      public void post() {
      }

    });

  }



  public void __init() {
    root = new UnsignedInteger(256, new BigInteger("0"));
    paths2_root = (UnsignedInteger[]) UnsignedInteger.createZeroArray(CircuitGenerator.__getActiveCircuitGenerator(), new int[]{18}, 256);
    leaf = (UnsignedInteger[]) UnsignedInteger.createZeroArray(CircuitGenerator.__getActiveCircuitGenerator(), new int[]{16}, 256);
    leafNode = new Leaf[16];
    path = (UnsignedInteger[]) UnsignedInteger.createZeroArray(CircuitGenerator.__getActiveCircuitGenerator(), new int[]{18}, 256);
    branch1 = new MerkleTree[64];
    branch2 = new MerkleTree[32];
    branch3 = new MerkleTree[16];
    branch4 = new MerkleTree[8];
    branch5 = new MerkleTree[4];
    branch6 = new MerkleTree[2];
    merkle_root = new UnsignedInteger(256, new BigInteger("0"));
    r = (UnsignedInteger[]) UnsignedInteger.createZeroArray(CircuitGenerator.__getActiveCircuitGenerator(), new int[]{128}, 64);
    s = (UnsignedInteger[]) UnsignedInteger.createZeroArray(CircuitGenerator.__getActiveCircuitGenerator(), new int[]{128}, 64);
    signature = (UnsignedInteger[]) UnsignedInteger.createZeroArray(CircuitGenerator.__getActiveCircuitGenerator(), new int[]{128}, 64);
    publicKey = (UnsignedInteger[][]) UnsignedInteger.createZeroArray(CircuitGenerator.__getActiveCircuitGenerator(), new int[]{128, 2}, 64);
    n = new UnsignedInteger(64, new BigInteger("7"));
    z = (UnsignedInteger[]) UnsignedInteger.createZeroArray(CircuitGenerator.__getActiveCircuitGenerator(), new int[]{128}, 64);
    smodInv = new UnsignedInteger(64, new BigInteger("0"));
    two = new UnsignedInteger(64, new BigInteger("2"));
    a = new UnsignedInteger(64, new BigInteger("3"));
    three = new UnsignedInteger(64, new BigInteger("3"));
    G = (UnsignedInteger[]) UnsignedInteger.createZeroArray(CircuitGenerator.__getActiveCircuitGenerator(), new int[]{2}, 64);
    tes = new UnsignedInteger(64, new BigInteger("0"));
  }

  public LeafExistence merkle;
  public UnsignedInteger root;
  public UnsignedInteger[] paths2_root;
  public UnsignedInteger[] leaf;
  public Leaf[] leafNode;
  public UnsignedInteger[] path;
  public MerkleTree[] branch1;
  public MerkleTree[] branch2;
  public MerkleTree[] branch3;
  public MerkleTree[] branch4;
  public MerkleTree[] branch5;
  public MerkleTree[] branch6;
  public MerkleTree merkleroot;
  public UnsignedInteger merkle_root;
  public String msg;
  public UnsignedInteger[] r;
  public UnsignedInteger[] s;
  public UnsignedInteger[] signature;
  public UnsignedInteger[][] publicKey;
  public UnsignedInteger n;
  public UnsignedInteger[] z;
  public UnsignedInteger smodInv;
  public UnsignedInteger two;
  public UnsignedInteger a;
  public UnsignedInteger three;
  public UnsignedInteger[] G;
  public UnsignedInteger tes;
  public boolean valid;

  @Override
  public void __defineInputs() {
    super.__defineInputs();
    root = UnsignedInteger.createInput(this, 256);



    path = (UnsignedInteger[]) UnsignedInteger.createInputArray(CircuitGenerator.__getActiveCircuitGenerator(), Util.getArrayDimensions(path), 256);












  }
  @Override
  public void __defineOutputs() {
    super.__defineOutputs();
    UnsignedInteger.makeOutput(this, root);









  }
  @Override
  public void __defineVerifiedWitnesses() {
    super.__defineVerifiedWitnesses();



















  }
  @Override
  public void __defineWitnesses() {
    super.__defineWitnesses();

















  }
  public void outsource() {
    // Entry point for the circuit. Input and witness arrays/structs must be instantiated outside this method 

    // 

    // generate merkle tree 
    for (int i = 0; i < 18; i++) {
      paths2_root[i].assign(path[i], 256);
    }



    UnsignedInteger j = new UnsignedInteger(256, new BigInteger("0"));

    j.assign(path[0], 256);
    for (int i = 1; i < 18; i++) {
      j.assign(j.add(paths2_root[i]), 256);
    }

    {
      Bit bit_o0sb = j.isEqualTo(root).copy();
      boolean c_o0sb = CircuitGenerator.__getActiveCircuitGenerator().__checkConstantState(bit_o0sb);
      if (c_o0sb) {
        if (bit_o0sb.getConstantValue()) {
          valid = true;
        } else {
          valid = false;

        }
      } else {
        ConditionalScopeTracker.pushMain();
        ConditionalScopeTracker.push(bit_o0sb);
        valid = true;

        ConditionalScopeTracker.pop();

        ConditionalScopeTracker.push(new Bit(true));

        valid = false;
        ConditionalScopeTracker.pop();
        ConditionalScopeTracker.popMain();
      }

    }

    // 这里的digest（摘要）为什么是简单的做add运算？ 

    // ECDSA整个过程代码 


    // ECDSA签名验证 
    // 


    // S^-1*z*G+S^-1*r*pk 


    // 
  }
  public UnsignedInteger[] pointMultiply(UnsignedInteger[] p1, UnsignedInteger n, UnsignedInteger a, UnsignedInteger mult) {
    tes.assign(mult, 64);
    UnsignedInteger[] val = (UnsignedInteger[]) UnsignedInteger.createZeroArray(CircuitGenerator.__getActiveCircuitGenerator(), new int[]{2}, 64);
    UnsignedInteger[] doubledP = p1;

    boolean set = false;
    Bit[] binMult = mult.getBitElements();
    UnsignedInteger mid = new UnsignedInteger(64, new BigInteger("1"));
    Bit[] num = mid.getBitElements();

    // 找到binMult的长度 
    // 这里求binMultLen有点问题，需要再看一下 
    Bit[] bittes = tes.getBitElements();
    int binMultLen = 0;
    boolean flag = false;
    for (int i = binMult.length - 1; i >= 0; i--) {
      {
        Bit bit_a0o0wb_0 = bittes[i].copy();
        boolean c_a0o0wb_0 = CircuitGenerator.__getActiveCircuitGenerator().__checkConstantState(bit_a0o0wb_0);
        if (c_a0o0wb_0) {
          if (bit_a0o0wb_0.getConstantValue()) {
            if (flag == false) {
              flag = true;
              binMultLen = i;
            }
          } else {

          }
        } else {
          ConditionalScopeTracker.pushMain();
          ConditionalScopeTracker.push(bit_a0o0wb_0);
          if (flag == false) {
            flag = true;
            binMultLen = i;
          }

          ConditionalScopeTracker.pop();

          ConditionalScopeTracker.push(new Bit(true));

          ConditionalScopeTracker.pop();
          ConditionalScopeTracker.popMain();
        }

      }
    }
    System.out.println("binmultLen: " + binMultLen);
    for (int c = binMultLen; c >= 0; c--) {
      {
        Bit bit_a0q0wb_0 = binMult[c].isEqualTo(num[0]).copy();
        boolean c_a0q0wb_0 = CircuitGenerator.__getActiveCircuitGenerator().__checkConstantState(bit_a0q0wb_0);
        if (c_a0q0wb_0) {
          if (bit_a0q0wb_0.getConstantValue()) {
            if (set) {
              val = pointAddition(val, doubledP, n.copy(64));
            } else {
              val = doubledP;
              set = true;
            }
          } else {

          }
        } else {
          ConditionalScopeTracker.pushMain();
          ConditionalScopeTracker.push(bit_a0q0wb_0);
          if (set) {
            val = pointAddition(val, doubledP, n.copy(64));
          } else {
            val = doubledP;
            set = true;
          }

          ConditionalScopeTracker.pop();

          ConditionalScopeTracker.push(new Bit(true));

          ConditionalScopeTracker.pop();
          ConditionalScopeTracker.popMain();
        }

      }
      doubledP = pointDoubling(doubledP, n.copy(64), a.copy(64));
    }
    return val;
  }
  public UnsignedInteger[] pointAddition(UnsignedInteger[] p1, UnsignedInteger[] p2, UnsignedInteger n) {
    UnsignedInteger[] val = (UnsignedInteger[]) UnsignedInteger.createZeroArray(CircuitGenerator.__getActiveCircuitGenerator(), new int[]{2}, 64);

    UnsignedInteger a = p2[1].subtract(p1[1]).copy(64);
    UnsignedInteger b = p2[0].subtract(p1[0]).copy(64);
    b.assign(modInv(b.copy(64), n.subtract(two).copy(64), n.copy(64)), 64);

    a.assign(a.mul(b).mod(n), 64);
    b.assign(a.mul(a), 64);
    b.assign((b.subtract(p1[0]).subtract(p2[0])).mod(n), 64);
    val[0].assign(b, 64);
    val[1].assign((a.mul((p1[0].subtract(b))).subtract(p1[1])).mod(n), 64);

    return val;
  }
  public UnsignedInteger[] pointDoubling(UnsignedInteger[] p1, UnsignedInteger n, UnsignedInteger a) {
    UnsignedInteger[] val = (UnsignedInteger[]) UnsignedInteger.createZeroArray(CircuitGenerator.__getActiveCircuitGenerator(), new int[]{2}, 64);

    UnsignedInteger i = p1[0].mul(p1[0]).mul(three).add(a).copy(64);
    UnsignedInteger j = p1[1].mul(two).copy(64);
    j.assign(modInv(j.copy(64), n.subtract(two).copy(64), n.copy(64)), 64);

    i.assign(i.mul(j).mod(n), 64);
    j.assign(i.mul(i), 64);
    j.assign((j.subtract((p1[0].mul(two)))).mod(n), 64);
    val[0].assign(j, 64);
    val[1].assign((i.mul((p1[0].subtract(j))).subtract(p1[1])).mod(n), 64);

    return val;
  }
  public UnsignedInteger modInv(UnsignedInteger b, UnsignedInteger q, UnsignedInteger p) {
    UnsignedInteger ans = new UnsignedInteger(64, new BigInteger("1"));
    b.assign(b.mod(p), 64);

    Bit[] qq = q.getBitElements();
    boolean flag = false;
    int fl = 0;
    // 找到数的第一个1的索引 
    for (int i = qq.length - 1; i >= 0; i--) {
      {
        Bit bit_a0h0fc_0 = qq[i].copy();
        boolean c_a0h0fc_0 = CircuitGenerator.__getActiveCircuitGenerator().__checkConstantState(bit_a0h0fc_0);
        if (c_a0h0fc_0) {
          if (bit_a0h0fc_0.getConstantValue()) {
            if (flag == false) {
              flag = true;
              fl = i;
            }
          } else {

          }
        } else {
          ConditionalScopeTracker.pushMain();
          ConditionalScopeTracker.push(bit_a0h0fc_0);
          if (flag == false) {
            flag = true;
            fl = i;
          }

          ConditionalScopeTracker.pop();

          ConditionalScopeTracker.push(new Bit(true));

          ConditionalScopeTracker.pop();
          ConditionalScopeTracker.popMain();
        }

      }
    }
    // 求模的逆元 
    for (int i = 0; i <= fl; i++) {
      {
        Bit bit_a0j0fc_0 = qq[i].copy();
        boolean c_a0j0fc_0 = CircuitGenerator.__getActiveCircuitGenerator().__checkConstantState(bit_a0j0fc_0);
        if (c_a0j0fc_0) {
          if (bit_a0j0fc_0.getConstantValue()) {
            ans.assign(ans.mul(b).mod(p), 64);
          } else {

          }
        } else {
          ConditionalScopeTracker.pushMain();
          ConditionalScopeTracker.push(bit_a0j0fc_0);
          ans.assign(ans.mul(b).mod(p), 64);

          ConditionalScopeTracker.pop();

          ConditionalScopeTracker.push(new Bit(true));

          ConditionalScopeTracker.pop();
          ConditionalScopeTracker.popMain();
        }

      }
      b.assign(b.mul(b).mod(p), 64);
    }
    ans.assign(ans.mod(p), 64);
    return ans;
  }

  public void __generateSampleInput(CircuitEvaluator evaluator) {
    __generateRandomInput(evaluator);
  }

}
