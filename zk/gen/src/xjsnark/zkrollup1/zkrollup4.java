package xjsnark.zkrollup1;

/*Generated by MPS */

import backend.structure.CircuitGenerator;
import backend.config.Config;
import backend.eval.SampleRun;
import java.math.BigInteger;
import backend.auxTypes.UnsignedInteger;
import util.Util;
import backend.auxTypes.Bit;
import backend.auxTypes.ConditionalScopeTracker;
import backend.eval.CircuitEvaluator;

public class zkrollup4 extends CircuitGenerator {



  public static void main(String[] args) {
    // This is the java main method. Its purpose is to make the Progam runnable in the environment 
    // This method can be left empty, or used to set Configuration params (see examples) 
    Config.writeCircuits = true;
    Config.outputFilesPath = "zk_output";
    new zkrollup4();
  }

  public zkrollup4() {
    super("zkrollup4");
    __generateCircuit();
    this.__evaluateSampleRun(new SampleRun("Sample_Run4", true) {
      public void pre() {
        // verify merkle tree 输入 
        // check the equality between root and merkle_root 
        // input tx root === computed tx root 

        // generate merkle tree input 
        for (int i = 0; i < 4; i++) {
          leaf[i].mapValue(new BigInteger("0"), CircuitGenerator.__getActiveCircuitGenerator().__getCircuitEvaluator());
        }

        new_data[0].mapValue(new BigInteger("02318541838266450017226345765875318784227389175109987470325706581956743168"), CircuitGenerator.__getActiveCircuitGenerator().__getCircuitEvaluator());
        new_data[1].mapValue(new BigInteger("199678946102687178006387784425989776461064793512468678049243241428647007911921"), CircuitGenerator.__getActiveCircuitGenerator().__getCircuitEvaluator());
        new_data[2].mapValue(new BigInteger("4632631417707725340550051625121310191901349125906867621047675261135121622357"), CircuitGenerator.__getActiveCircuitGenerator().__getCircuitEvaluator());
        new_data[3].mapValue(new BigInteger("6267601602674274812771330857649753689719128395848935748943150712030500357798"), CircuitGenerator.__getActiveCircuitGenerator().__getCircuitEvaluator());




        // ECDSA输入 

      }
      public void post() {
      }

    });

  }



  public void __init() {
    root = new UnsignedInteger(32, new BigInteger("0"));
    paths2_root_pos = (UnsignedInteger[]) UnsignedInteger.createZeroArray(CircuitGenerator.__getActiveCircuitGenerator(), new int[]{2}, 32);
    paths2_root = (UnsignedInteger[]) UnsignedInteger.createZeroArray(CircuitGenerator.__getActiveCircuitGenerator(), new int[]{2}, 32);
    leaf = (UnsignedInteger[]) UnsignedInteger.createZeroArray(CircuitGenerator.__getActiveCircuitGenerator(), new int[]{4}, 256);
    leafNode = new Leaf[4];
    new_data = (UnsignedInteger[]) UnsignedInteger.createZeroArray(CircuitGenerator.__getActiveCircuitGenerator(), new int[]{4}, 256);
    branch1 = new MerkleTree[64];
    branch2 = new MerkleTree[32];
    branch3 = new MerkleTree[16];
    branch4 = new MerkleTree[8];
    branch5 = new MerkleTree[4];
    branch6 = new MerkleTree[2];
    merkle_root = new UnsignedInteger(256, new BigInteger("0"));
    r = (UnsignedInteger[]) UnsignedInteger.createZeroArray(CircuitGenerator.__getActiveCircuitGenerator(), new int[]{128}, 64);
    s = (UnsignedInteger[]) UnsignedInteger.createZeroArray(CircuitGenerator.__getActiveCircuitGenerator(), new int[]{128}, 64);
    signature = (UnsignedInteger[]) UnsignedInteger.createZeroArray(CircuitGenerator.__getActiveCircuitGenerator(), new int[]{128}, 64);
    publicKey = (UnsignedInteger[][]) UnsignedInteger.createZeroArray(CircuitGenerator.__getActiveCircuitGenerator(), new int[]{128, 2}, 64);
    n = new UnsignedInteger(64, new BigInteger("7"));
    z = (UnsignedInteger[]) UnsignedInteger.createZeroArray(CircuitGenerator.__getActiveCircuitGenerator(), new int[]{128}, 64);
    smodInv = new UnsignedInteger(64, new BigInteger("0"));
    two = new UnsignedInteger(64, new BigInteger("2"));
    a = new UnsignedInteger(64, new BigInteger("3"));
    three = new UnsignedInteger(64, new BigInteger("3"));
    G = (UnsignedInteger[]) UnsignedInteger.createZeroArray(CircuitGenerator.__getActiveCircuitGenerator(), new int[]{2}, 64);
    tes = new UnsignedInteger(64, new BigInteger("0"));
  }

  public LeafExistence merkle;
  public UnsignedInteger root;
  public UnsignedInteger[] paths2_root_pos;
  public UnsignedInteger[] paths2_root;
  public UnsignedInteger[] leaf;
  public Leaf[] leafNode;
  public UnsignedInteger[] new_data;
  public MerkleTree[] branch1;
  public MerkleTree[] branch2;
  public MerkleTree[] branch3;
  public MerkleTree[] branch4;
  public MerkleTree[] branch5;
  public MerkleTree[] branch6;
  public MerkleTree merkleroot;
  public UnsignedInteger merkle_root;
  public String msg;
  public UnsignedInteger[] r;
  public UnsignedInteger[] s;
  public UnsignedInteger[] signature;
  public UnsignedInteger[][] publicKey;
  public UnsignedInteger n;
  public UnsignedInteger[] z;
  public UnsignedInteger smodInv;
  public UnsignedInteger two;
  public UnsignedInteger a;
  public UnsignedInteger three;
  public UnsignedInteger[] G;
  public UnsignedInteger tes;

  @Override
  public void __defineInputs() {
    super.__defineInputs();



    leaf = (UnsignedInteger[]) UnsignedInteger.createInputArray(CircuitGenerator.__getActiveCircuitGenerator(), Util.getArrayDimensions(leaf), 256);
    new_data = (UnsignedInteger[]) UnsignedInteger.createInputArray(CircuitGenerator.__getActiveCircuitGenerator(), Util.getArrayDimensions(new_data), 256);












  }
  @Override
  public void __defineOutputs() {
    super.__defineOutputs();
    UnsignedInteger.makeOutput(this, merkle_root);









  }
  @Override
  public void __defineVerifiedWitnesses() {
    super.__defineVerifiedWitnesses();



















  }
  @Override
  public void __defineWitnesses() {
    super.__defineWitnesses();

















  }
  public void outsource() {
    // Entry point for the circuit. Input and witness arrays/structs must be instantiated outside this method 

    // 

    // generate merkle tree 
    for (int i = 0; i < 4; i++) {
      leafNode[i] = new Leaf(leaf[i].copy(256));
    }


    System.out.println("leaf.datablock: " + leafNode[0].dataBlock);

    int j = 0;


    j = 0;
    for (int i = 0; i < 4; i++) {
      branch5[i] = new MerkleTree();
      branch5[i].add(leafNode[j], new Leaf(new_data[j].copy(256)));
      j = j + 1;
    }

    j = 0;
    for (int i = 0; i < 2; i++) {
      branch6[i] = new MerkleTree();
      branch6[i].add(branch5[j], branch5[j + 1]);
      j = j + 2;
    }

    merkleroot = new MerkleTree();
    merkleroot.add(branch6[0], branch6[1]);
    merkle_root.assign(merkleroot.digest, 256);
    // 这里的digest（摘要）为什么是简单的做add运算？ 

    // ECDSA整个过程代码 


    // ECDSA签名验证 
    // 


    // S^-1*z*G+S^-1*r*pk 


    // 
  }
  public UnsignedInteger[] pointMultiply(UnsignedInteger[] p1, UnsignedInteger n, UnsignedInteger a, UnsignedInteger mult) {
    tes.assign(mult, 64);
    UnsignedInteger[] val = (UnsignedInteger[]) UnsignedInteger.createZeroArray(CircuitGenerator.__getActiveCircuitGenerator(), new int[]{2}, 64);
    UnsignedInteger[] doubledP = p1;

    boolean set = false;
    Bit[] binMult = mult.getBitElements();
    UnsignedInteger mid = new UnsignedInteger(64, new BigInteger("1"));
    Bit[] num = mid.getBitElements();

    // 找到binMult的长度 
    // 这里求binMultLen有点问题，需要再看一下 
    Bit[] bittes = tes.getBitElements();
    int binMultLen = 0;
    boolean flag = false;
    for (int i = binMult.length - 1; i >= 0; i--) {
      {
        Bit bit_a0o0wb_1 = bittes[i].copy();
        boolean c_a0o0wb_1 = CircuitGenerator.__getActiveCircuitGenerator().__checkConstantState(bit_a0o0wb_1);
        if (c_a0o0wb_1) {
          if (bit_a0o0wb_1.getConstantValue()) {
            if (flag == false) {
              flag = true;
              binMultLen = i;
            }
          } else {

          }
        } else {
          ConditionalScopeTracker.pushMain();
          ConditionalScopeTracker.push(bit_a0o0wb_1);
          if (flag == false) {
            flag = true;
            binMultLen = i;
          }

          ConditionalScopeTracker.pop();

          ConditionalScopeTracker.push(new Bit(true));

          ConditionalScopeTracker.pop();
          ConditionalScopeTracker.popMain();
        }

      }
    }
    System.out.println("binmultLen: " + binMultLen);
    for (int c = binMultLen; c >= 0; c--) {
      {
        Bit bit_a0q0wb_1 = binMult[c].isEqualTo(num[0]).copy();
        boolean c_a0q0wb_1 = CircuitGenerator.__getActiveCircuitGenerator().__checkConstantState(bit_a0q0wb_1);
        if (c_a0q0wb_1) {
          if (bit_a0q0wb_1.getConstantValue()) {
            if (set) {
              val = pointAddition(val, doubledP, n.copy(64));
            } else {
              val = doubledP;
              set = true;
            }
          } else {

          }
        } else {
          ConditionalScopeTracker.pushMain();
          ConditionalScopeTracker.push(bit_a0q0wb_1);
          if (set) {
            val = pointAddition(val, doubledP, n.copy(64));
          } else {
            val = doubledP;
            set = true;
          }

          ConditionalScopeTracker.pop();

          ConditionalScopeTracker.push(new Bit(true));

          ConditionalScopeTracker.pop();
          ConditionalScopeTracker.popMain();
        }

      }
      doubledP = pointDoubling(doubledP, n.copy(64), a.copy(64));
    }
    return val;
  }
  public UnsignedInteger[] pointAddition(UnsignedInteger[] p1, UnsignedInteger[] p2, UnsignedInteger n) {
    UnsignedInteger[] val = (UnsignedInteger[]) UnsignedInteger.createZeroArray(CircuitGenerator.__getActiveCircuitGenerator(), new int[]{2}, 64);

    UnsignedInteger a = p2[1].subtract(p1[1]).copy(64);
    UnsignedInteger b = p2[0].subtract(p1[0]).copy(64);
    b.assign(modInv(b.copy(64), n.subtract(two).copy(64), n.copy(64)), 64);

    a.assign(a.mul(b).mod(n), 64);
    b.assign(a.mul(a), 64);
    b.assign((b.subtract(p1[0]).subtract(p2[0])).mod(n), 64);
    val[0].assign(b, 64);
    val[1].assign((a.mul((p1[0].subtract(b))).subtract(p1[1])).mod(n), 64);

    return val;
  }
  public UnsignedInteger[] pointDoubling(UnsignedInteger[] p1, UnsignedInteger n, UnsignedInteger a) {
    UnsignedInteger[] val = (UnsignedInteger[]) UnsignedInteger.createZeroArray(CircuitGenerator.__getActiveCircuitGenerator(), new int[]{2}, 64);

    UnsignedInteger i = p1[0].mul(p1[0]).mul(three).add(a).copy(64);
    UnsignedInteger j = p1[1].mul(two).copy(64);
    j.assign(modInv(j.copy(64), n.subtract(two).copy(64), n.copy(64)), 64);

    i.assign(i.mul(j).mod(n), 64);
    j.assign(i.mul(i), 64);
    j.assign((j.subtract((p1[0].mul(two)))).mod(n), 64);
    val[0].assign(j, 64);
    val[1].assign((i.mul((p1[0].subtract(j))).subtract(p1[1])).mod(n), 64);

    return val;
  }
  public UnsignedInteger modInv(UnsignedInteger b, UnsignedInteger q, UnsignedInteger p) {
    UnsignedInteger ans = new UnsignedInteger(64, new BigInteger("1"));
    b.assign(b.mod(p), 64);

    Bit[] qq = q.getBitElements();
    boolean flag = false;
    int fl = 0;
    // 找到数的第一个1的索引 
    for (int i = qq.length - 1; i >= 0; i--) {
      {
        Bit bit_a0h0fc_1 = qq[i].copy();
        boolean c_a0h0fc_1 = CircuitGenerator.__getActiveCircuitGenerator().__checkConstantState(bit_a0h0fc_1);
        if (c_a0h0fc_1) {
          if (bit_a0h0fc_1.getConstantValue()) {
            if (flag == false) {
              flag = true;
              fl = i;
            }
          } else {

          }
        } else {
          ConditionalScopeTracker.pushMain();
          ConditionalScopeTracker.push(bit_a0h0fc_1);
          if (flag == false) {
            flag = true;
            fl = i;
          }

          ConditionalScopeTracker.pop();

          ConditionalScopeTracker.push(new Bit(true));

          ConditionalScopeTracker.pop();
          ConditionalScopeTracker.popMain();
        }

      }
    }
    // 求模的逆元 
    for (int i = 0; i <= fl; i++) {
      {
        Bit bit_a0j0fc_1 = qq[i].copy();
        boolean c_a0j0fc_1 = CircuitGenerator.__getActiveCircuitGenerator().__checkConstantState(bit_a0j0fc_1);
        if (c_a0j0fc_1) {
          if (bit_a0j0fc_1.getConstantValue()) {
            ans.assign(ans.mul(b).mod(p), 64);
          } else {

          }
        } else {
          ConditionalScopeTracker.pushMain();
          ConditionalScopeTracker.push(bit_a0j0fc_1);
          ans.assign(ans.mul(b).mod(p), 64);

          ConditionalScopeTracker.pop();

          ConditionalScopeTracker.push(new Bit(true));

          ConditionalScopeTracker.pop();
          ConditionalScopeTracker.popMain();
        }

      }
      b.assign(b.mul(b).mod(p), 64);
    }
    ans.assign(ans.mod(p), 64);
    return ans;
  }

  public void __generateSampleInput(CircuitEvaluator evaluator) {
    __generateRandomInput(evaluator);
  }

}
