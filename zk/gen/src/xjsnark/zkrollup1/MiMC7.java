package xjsnark.zkrollup1;

/*Generated by MPS */

import backend.auxTypes.UnsignedInteger;
import java.math.BigInteger;
import backend.structure.CircuitGenerator;

public class MiMC7 {
  public UnsignedInteger x_in = new UnsignedInteger(256, new BigInteger("0"));
  public UnsignedInteger k = new UnsignedInteger(256, new BigInteger("0"));
  public UnsignedInteger out = new UnsignedInteger(256, new BigInteger("0"));

  public UnsignedInteger[] c = {new UnsignedInteger(256, new BigInteger("0")), new UnsignedInteger(256, new BigInteger("1")), new UnsignedInteger(256, new BigInteger("2")), new UnsignedInteger(256, new BigInteger("3")), new UnsignedInteger(256, new BigInteger("4")), new UnsignedInteger(256, new BigInteger("5")), new UnsignedInteger(256, new BigInteger("6")), new UnsignedInteger(256, new BigInteger("7")), new UnsignedInteger(256, new BigInteger("8")), new UnsignedInteger(256, new BigInteger("9")), new UnsignedInteger(256, new BigInteger("10")), new UnsignedInteger(256, new BigInteger("11")), new UnsignedInteger(256, new BigInteger("12"))};

  public UnsignedInteger t = new UnsignedInteger(256, new BigInteger("0"));
  public UnsignedInteger[] t2;
  public UnsignedInteger[] t4;
  public UnsignedInteger[] t6;
  public UnsignedInteger[] t7;

  public MiMC7(int nrounds, UnsignedInteger in, UnsignedInteger r) {
    // 修改了MiMC7算法，作为Merkle树的hash算法，在聚合时，左子树（叶子）作为算法输入的in，右子树（叶子）作为算法输入的r 
    this.x_in.assign(in, 256);
    this.k.assign(r, 256);

    t2 = (UnsignedInteger[]) UnsignedInteger.createZeroArray(CircuitGenerator.__getActiveCircuitGenerator(), new int[]{nrounds}, 256);
    t4 = (UnsignedInteger[]) UnsignedInteger.createZeroArray(CircuitGenerator.__getActiveCircuitGenerator(), new int[]{nrounds}, 256);
    t6 = (UnsignedInteger[]) UnsignedInteger.createZeroArray(CircuitGenerator.__getActiveCircuitGenerator(), new int[]{nrounds}, 256);
    t7 = (UnsignedInteger[]) UnsignedInteger.createZeroArray(CircuitGenerator.__getActiveCircuitGenerator(), new int[]{nrounds - 1}, 256);
    for (int i = 0; i < nrounds; i++) {
      if (i == 0) {
        t.assign(k.add(x_in), 256);
      } else {
        t.assign(k.add(t7[i - 1]).add(c[i]), 256);
      }
      t2[i].assign(t.mul(t), 256);
      t4[i].assign(t2[i].mul(t2[i]), 256);
      t6[i].assign(t4[i].mul(t2[i]), 256);
      if (i < nrounds - 1) {
        t7[i].assign(t6[i].mul(t), 256);
      } else {
        out.assign(t6[i].mul(t).add(k), 256);
      }
    }
  }



}
