package xjsnark.zkrollup1;

/*Generated by MPS */

import java.math.BigInteger;

public class EcOperation {

  // 椭圆曲线中P+Q的情况
  public static BigInteger[] pointAddition(BigInteger[] p1, BigInteger[] p2, BigInteger n) {
    BigInteger[] val = new BigInteger[2];

    BigInteger a = (p2[1].subtract(p1[1]));
    BigInteger b = (p2[0].subtract(p1[0]));
    b = b.modInverse(n);
    a = a.multiply(b).mod(n);
    b = a.multiply(a);
    b = (b.subtract(p1[0])).subtract(p2[0]).mod(n);
    val[0] = b;

    val[1] = (a.multiply(p1[0].subtract(b))).subtract(p1[1].mod(n));

    return val;
  }

  // 椭圆曲线中P+P的情况
  public static BigInteger[] pointDoubling(BigInteger[] p1, BigInteger n, BigInteger a) {
    BigInteger[] val = new BigInteger[2];

    BigInteger i = p1[0].multiply(p1[0]).multiply(BigInteger.valueOf(3)).add(a);
    BigInteger j = (p1[1].multiply(BigInteger.valueOf(2))).modInverse(n);
    i = (i.multiply(j)).mod(n);
    j = i.multiply(i);
    j = (j.subtract(p1[0].multiply(BigInteger.valueOf(2)))).mod(n);
    val[0] = j;

    val[1] = (i.multiply(p1[0].subtract(j))).subtract(p1[1]).mod(n);

    return val;
  }

  // mult表示私钥，p1表示椭圆曲线上面的一点，返回的是曲线上的另一个点，也就是公钥
  // 即publickey=privateket*point1
  // n是模运算的底
  public static BigInteger[] pointMultiply(BigInteger[] p1, BigInteger n, BigInteger a, BigInteger mult) {
    BigInteger[] val = new BigInteger[2];
    BigInteger[] doubledP = p1;

    boolean set = false;
    // 将私钥转换成二进制字符串 
    String binMult = mult.toString(2);
    int binMultLen = binMult.length();

    for (int c = binMultLen - 1; c >= 0; c--) {
      // System.out.print("|"+c+"|"); 

      if (binMult.charAt(c) == '1') {
        if (set) {
          val = pointAddition(val, doubledP, n);
        } else {
          // set作用就是在遇到第一个'1'时把doubledP赋值给val 
          val = doubledP;
          set = true;
        }
      }
      doubledP = pointDoubling(doubledP, n, a);
    }
    return val;
  }

}
